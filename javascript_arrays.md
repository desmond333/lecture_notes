## Август 2021 года
## Коспект по теории методов массивов в JS для frontend разработки

## Методы массивов
Мы уже знаем методы, которые добавляют и удаляют элементы из начала или конца:  
 • `arr.push(...items)` – добавляет элементы в конец,  
 • `arr.pop()` – извлекает элемент из конца,  
 • `arr.shift()` – извлекает элемент из начала,  
 • `arr.unshift(...items)` – добавляет элементы в начало.  

#### splice, slice  
1.) `splice`:  
Метод `arr.splice(str)` – это универсальный «швейцарский нож» для работы с массивами. Умеет всё: добавлять, удалять и заменять элементы.

Его синтаксис:  
`arr.splice(index[, deleteCount, elem1, ..., elemN])`

Он начинает с позиции `index`, удаляет `deleteCount` элементов и вставляет `elem1, ..., elemN` на их место. Возвращает массив из удалённых элементов.  
Этот метод проще всего понять, рассмотрев примеры.  
Начнём с удаления:  

```javascript
let arr = ["Я", "изучаю", "JavaScript"];
arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент
alert( arr ); // осталось ["Я", "JavaScript"]
```

Легко, правда? Начиная с позиции 1, он убрал 1 элемент.

В следующем примере мы удалим 3 элемента и заменим их двумя другими.
```javascript
let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
// удалить 3 первых элемента и заменить их другими
arr.splice(0, 3, "Давай", "танцевать");
alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]
```

Здесь видно, что `splice` возвращает массив из удалённых элементов:
```javascript
let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
// удалить 2 первых элемента
let removed = arr.splice(0, 2);
alert( removed ); // "Я", "изучаю" <-- массив из удалённых элементов
```

Метод `splice` также может вставлять элементы без удаления, для этого достаточно установить `deleteCount` в 0:
```javascript
let arr = ["Я", "изучаю", "JavaScript"];
// с позиции 2
// удалить 0 элементов
// вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");
alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"
```

2.) `slice`:
Метод arr.slice намного проще, чем похожий на него `arr.splice`.  

Его синтаксис:  
`arr.slice([start], [end])`

Он возвращает новый массив, в который копирует элементы, начиная с индекса `start` и до `end` (не включая `end`). Оба индекса `start` и `end` могут быть отрицательными. В таком случае отсчёт будет осуществляться с конца массива.  

Это похоже на строковый метод `str.slice`, но вместо подстрок возвращает подмассивы.  
Например:
```javascript
let arr = ["t", "e", "s", "t"];
alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)
alert( arr.slice(-2) ); // s,t (копирует с -2 до конца)
```  

Можно вызвать `slice` и вообще без аргументов: `arr.slice()` создаёт копию массива `arr`. Это часто используют, чтобы создать копию массива для дальнейших преобразований, которые не должны менять исходный массив.

#### Преобразование массива
1.) `map`:  
Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.  
```javascript
let result = arr.map(function(item, index, array) {
  // возвращается новое значение вместо элемента
});
```

2.) `reverse`:  
Метод `arr.reverse` возращает измененный массив с обратным порядком элементов.  
Пример:  
```javascript
let arr = [1, 2, 3, 4, 5];  
arr.reverse();   
alert( arr ); // 5,4,3,2,1 
``` 

3.) `split` и `join`:  
a.) Метод `str.split(delim)` разбивает строку на массив по заданному разделителю `delim`. У метода `split` есть необязательный второй числовой аргумент – ограничение на количество элементов в массиве. 
```javascript
let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);  
alert(arr); // Вася, Петя 
``` 

Вызов `split(s)` с пустым аргументом s разбил бы строку на массив букв:  
```javascript
let str = "тест";  
alert( str.split('') ); // т,е,с,т 
``` 

б.) Вызов `arr.join(glue)` делает в точности противоположное `split`. Он создаёт строку из элементов arr, вставляя glue между ними.  
Например:  
```javascript
let arr = ['Вася', 'Петя', 'Маша'];    
let str = arr.join(';'); // объединить массив в строку через ;  
alert( str ); // Вася;Петя;Маша  
``` 

4.) `reduce(func, initial)` – вычисляет одно значение на основе всего массива, вызывая `func` для каждого элемента и передавая промежуточный результат между вызовами.  
```javascript
let value = arr.reduce(function(previousValue, item, index, array) {
  // ...
}, [initial]);
``` 

Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.  
Аргументы:  
1.) `previousValue` – результат предыдущего вызова этой функции, равен `initial` при первом вызове (если передан `initial`),  
2.) `item` – очередной элемент массива,  
3.) `index` – его индекс,  
4.) `array` – сам массив.  

При вызове функции результат её вызова на предыдущем элементе массива передаётся как первый аргумент.  

Звучит сложновато, но всё становится проще, если думать о первом аргументе как «аккумулирующем» результат предыдущих вызовов функции. По окончании он становится результатом `reduce`.  

Этот метод проще всего понять на примере.  

Тут мы получим сумму всех элементов массива всего одной строкой:
```javascript
let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result); // 15
``` 

Здесь мы использовали наиболее распространённый вариант `reduce`, который использует только 2 аргумента.  
Давайте детальнее разберём, как он работает.  

1.) При первом запуске `sum` равен `initial` (последний аргумент `reduce`), то есть 0, а `current` – первый элемент массива, равный 1. Таким образом, результат функции равен 1.  
2.) При втором запуске `sum = 1`, и к нему мы добавляем второй элемент массива (2).  
3.) При третьем запуске `sum = 3`, к которому мы добавляем следующий элемент, и так далее…  

Мы также можем опустить начальное значение:  
```javascript
let arr = [1, 2, 3, 4, 5];

// убрано начальное значение (нет 0 в конце)
let result = arr.reduce((sum, current) => sum + current);

alert( result ); // 15
``` 

Результат – точно такой же! Это потому, что при отсутствии initial в качестве первого значения берётся первый элемент массива, а перебор стартует со второго.  

Но такое использование требует крайней осторожности. Если массив пуст, то вызов reduce без начального значения выдаст ошибку.  
Вот пример:  
```javascript
let arr = [];

// Error: Reduce of empty array with no initial value
// если бы существовало начальное значение, reduce вернул бы его для пустого массива.
arr.reduce((sum, current) => sum + current);
``` 
Поэтому рекомендуется всегда указывать начальное значение.  

Метод arr.reduceRight работает аналогично, но проходит по массиву справа налево.  